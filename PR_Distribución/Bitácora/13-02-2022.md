# Domingo 13 de febrero del 2022

# Avances y comentarios

Anyelina
- No ah realizado comentarios ni ah reportado avances el dia de hoy.

Ligdenia
-se hiso la investigación,sobre la parte de Patriciones fijas
-se recopilqron datos de varios libros 
-Trabaje en la parte teórica para comprender cómo eran las particiones y cómo se ejecutaba. 
-se vieron videos, para poder entender bien el netbeas(dado que si lo he usado, pero no para un proyecto así) 
-Se guardo tota la información teórica sobre fixed partitions
-Investigación un poco más sobre las colas. 
-Tambien se investigó sobre los algoritmos de reubicación(dado que eso se ve como un problema q puede presentar en este tipo de partición 

NOTA: tuve problemas de salud, y también tuve problemas con la computadora, les comente lo sucedido amis compañeros, y les avise que por los inconvenientes que tuve no podía absolutamente continuar con mi parte de este proyecto. 

Ramon
- No ah realizado comentarios ni ah reportado avances el dia de hoy.

Marco
- 10:31-> Se hicieron algunos cambios en la <b>Interfaz de Particionamiento Dinamico</b>:
    - Se hizo mas grande la ventana del emulador.
    - Se hicieron mas grandes los paneles de memorias y se acomodaron en forma vertical.
    - En el area de control se agregaron dos grupos de componentes:
        - El primer grupo que se agrego fue el de Reubicacion. En este grupo se ingresa un numero de particion y el OS debe verificar si existe un proceso en dicha particion, en caso de que exista, este proceso sera reubicado en la otra memoria.
        - El segundo grupo que se agrego fue el de Compactacion. En este grupo se selecciona una memoria y el OS debera de encargarse de detectar las particiones sin procesos (fragmentacion externa) que en la interfaz son de color gris. Una vez detectadas las combina en una sola particion sin proceso (fragmento externo) y la coloca al final de la ultima particion con proceso.
- 10:42-> Se implemento el <b>Algoritmo de Reubicacion</b>, para esto se agregaron algunas funciones y se hicieron los siguientes cambios:
    - En el codigo fuente de la clase de la interfaz de particionamiento dinamico, en el metodo drawPartition, se agrego un parametro llamado "memory" el cual se utiliza para indicar de forma dinamica a que memoria pertenece la particion. Se agregaron las variables memorySize, memoryPanelWidth, memoryPanelHeight y memoryPanel; Las cuales cambian dinamicamente dependiendo de la memoria indicada.
    - En el codigo fuente de la clase de la interfaz de particionamiento dinamico, en el metodo changeBtnAction (Metodo que se activa al dar clic al boton cambiar del grupo de reubicacion) se agregaron las respectivas validaciones y dependiendo de la memoria seleccionada en la que se quiera cambiar el proceso, el OS ejecutara el metodo changeProcessMemory el cual recibe como parametros al numero de particion en que se desea buscar el proceso y tambien a la memoria en la que se encuentra dicha particion.
    - En la clase DynamicPartitionEngine, se agrego a el metodo changeProcessMemory el cual recibe como parametros al numero de particion para que ahi busque el proceso y a que memoria lo quiere mandar. Este metodo es una referencia al metodo de la clase Memory llamado swapProcess.
    -  En la clase Memory se agrego un metodo llamado getPartitionByNumber. Este metodo recibe como parametros al numero de particion que se desea retornar, un nodo de la memoria y la localidad de dicho nodo. Este metodo es una funcion recursiva que se encarga de recorrer todo los nodos en la memoria hasta encontrar el de la localidad deseada para finalmente retornarlo. Esta funcion es utilizada en el metodo swapProcess.
    - En la clase Memory se agrego un metodo llamado swapProcess. Este metodo recibe como parametros al numero de particion que se desea cambiar de memoria, a al objeto o instancia de memoria a la que se desea mandar. Este metodo primero se encarga de obtener la particion de la memoria origen utilizando el metodo getPArtitionByNumber con el numero de particion. Una vez obtenida la particion se encarga de verificar que exista un proceso en esa particion; Si el proceso existe se utilizara el metodo locateProcess en la memoria destino para copiar dicho proceso, y se eliminara el proceso en la memoria origen.
- 11:32-> Se implemento el <b>Algoritmo de Compactacion</b>, para esto se agregaron algunas funciones y se hicieron los siguientes cambios:
    - En el codigo fuente de la clase de la interfaz de particionamiento dinamico, en el metodo compactBtnAction (Metodo que se activa al dar clic al boton compactar del grupo de Compactacion) se agregaron las respectivas validaciones y dependiendo de la memoria seleccionada en la que se quiera compactar los fragmentos externos, el OS ejecutara el metodo compactMemory el cual recibe como parametros al un string que indique la memoria que se dessea compactar.
    - En la clase DynamicPartitionEngine, se agrego el metodo compactMemory, el cual recibe como parametro una variable que sirve para identificar que memoria se desea compactar y reducir la fragmentacion externa; Dependiendo de la variable se hace referencia al metodo "compact" de la clase Memory en la memoria indicada.
    - En la clase Memory, se agrego el metodo compact el cual analogicamente es una funcion exterior que ejecuta a la funcion interior innerCompact.
    - En la clase Memory, se agrego el metodo innerCompact. Este metodo se encarga de recorrer cada particion y detectar cuales no tienen procesos (fragmentos externos); Las particiones que detecta que no tienen procesos las mete en una lista de Nodos y dichas particiones las desvincula de la memoria. Una vez que se agregaron todos las particiones sin procesos a la lista "holes" se utiliza el metodo "mergeHoles" para convertirlas en una sola particion. Finalmente una vez que se cuente solamente con una particion sin procesos, esta sera unida despues de la ultima particion que si cuenta con procesos. El resultado final sera que todos las particiones con procesos (color amarillo) se encontraran a la izquierda de forma sucesiva seguidas de una sola particion sin procesos (color gris claro).
    - En la clase Memory, se agrego el metodo "mergeHoles". Este metodo recibe como parametro una lista de Nodos (Particiones sin procesos) y retorna un solo Nodo (Particion sin proceso) cuya tamano es equivalente a la suma de todos los nodos en la lista.
- 18:12-> Se implemento el <b>Algoritmo de Colocacion Best-fit</b> y el <b>Algoritmo de Colocacion Next-fit</b>, para esto se agregaron algunas funciones y se hicieron los siguientes cambios:
    - En el codigo fuente de la clase de la interfaz de particionamiento dinamico, en el metodo addBtnAction (Metodo que se activa al dar clic al boton agregar del grupo de Colocacion) se agregaron las respectivas validaciones y dependiendo del algoritmo seleccionado, el OS ejecutara el metodo addProcess el cual anteriormente se llamaba addProcessByFirst. El metodo addProcess funciona de forma general para los tres algoritmos de colocacion (first-fit, best-fit y next-fit) y recibe un nuevo parametro llamado algorithm para realizar acciones especificas dependiendo del algoritmo seleccionado.
    - En la clase DynamicPartitionEngine, tal como se menciono anteriormente se renombro el metodo addProcessByFirst con el nombre addProcess. El metodo addProcess es una referencia al metodo de la clase Memoria locateProcess.
    - En la clase Memory, se modifico el metodo locateProcess. El metodo locateProcess recibe como parametro un String llamado "algorithm" el cual es utilizado para llamar al metodo getFirstCanBeLocated (En caso de que el algoritmo sea First-fit), al metodo getBestCanBeLocated (En caso de que el algoritmo sea Best-fit) y sino se asume que el algoritmo seleccionado es el Next-fit. Si el algoritmo es Next-fit se utiliza el metodo getFirstCanBeLocated pero como parametro en vez de mandarle la primera particion de la memoria se le manda la ultima particion en la que se coloco un proceso, utilizando la variable privada "lastPlacement".
    - En la clase Memory, se agrego el metodo getBestCanBeLocated. Este metodo se encarga de retornar la particion sin proceso que mas se acerque al tamano del proceso que se desea agregar.
